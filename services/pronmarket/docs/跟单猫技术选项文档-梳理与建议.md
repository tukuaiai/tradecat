# 跟单猫技术选项文档：梳理与落地建议

更新时间：2025-12-18  
范围：仅基于 `docs/跟单猫技术选项文档.md` 与当前代码实现 `services/copy-trading-service/` 的对照解读。

---

## 0. 一句话结论

这份“技术选项文档”更像是**可行性导读 + 技术蓝图拼接**：方向总体正确（WS 实时监听、风控、OpSec、Telegram 交互），但在“信号源字段语义”和“下单参数语义”上存在混淆；落地时应优先把 **数据契约（Trade schema）+ 幂等 + BUY/SELL amount 语义 + 最小风控** 做到可验证、可回放，再谈“聪明钱发现引擎/NegRisk 等价映射/AI解释”。

---

## 1. 文档结构：两层内容叠在一起

### 1.1 可行性导读（偏产品/资源）

文档开头部分主要回答：
- 为什么值得做：预测市场门槛高、散户缺时间，跟单需求成立
- 竞品格局与差异化点：Telegram 极简交互、“首单识别”等
- 资源清单：列出一批开源仓库与官方 SDK（`clob-client`、`real-time-data-client`）

这部分可作为“立项依据”和“调研索引”，但其内容可信度参差：有些是经验判断，有些是外部仓库宣传语；不要直接当作系统规格。

### 1.2 技术蓝图长文（偏架构/工程）

从“混合架构/CLOB 机制/CTF/NegRisk”开始，文档切换为工程化视角：
- 解释 Polymarket 的混合架构与数据来源（链上结算、链下撮合）
- 给出系统分层：Monitor/Processor/Executor + Telegram 交互
- 强调 OpSec：密钥管理、代理、熔断等
- 给出阶段路线图：MVP → Alpha → Pro

这部分有价值，但落地必须做“契约化重写”（把关键假设写成可测试的接口/字段/时序）。

---

## 2. 文档里“值得保留”的架构骨架

### 2.1 单向流水线：监听 → 过滤/风控 → 执行 → 记录/通知

跟单系统的核心不是“能下单”，而是把一条流水线做成：
- 可观测（每一步都有日志/指标/trace）
- 可回放（能把历史 signal 重放验证策略）
- 可控（任何风控或熔断都能快速止血）

你当前 `services/copy-trading-service/` 已经具备这条流水线的雏形：
- `src/monitor.js`：监听（real-time-data-client）
- `src/executor.js`：下单（clob-client）
- `src/db/*`：记录（SQLite）
- `src/bot/index.js`：控制台（Telegram）

### 2.2 强约束：风控与安全不是“后期再加”

文档强调的风控点（比例、单笔上限、滑点保护、熔断窗口）是对的：这些属于系统“不变量”。跟单系统如果先放量再补风控，本质上是在用用户资金做测试。

### 2.3 信号质量是护城河

“聪明钱发现引擎”（例如基于 Dune/链上数据的筛选与淘汰）属于真正护城河；但它应该建立在**可靠的数据契约与执行引擎**之上，否则发现再准也无法稳定复制收益。

---

## 3. 文档最危险的点：信号源语义混淆

文档同时提到了：
- WebSocket 推送（real-time-data-client）
- maker/taker、side 反转
- 甚至提到 mempool/抢跑（在 Polymarket CLOB 场景下通常不成立）

问题不在“提法”，而在于落地时必须明确：

### 3.1 你真正能订阅到的公开交易流是什么？

当前代码订阅的是 `activity` topic，并只处理 `type === 'trades'`（见 `services/copy-trading-service/src/monitor.js`）。在官方 real-time-data-client 的 README 中，`activity/trades` 的字段关键点包含：
- `proxyWallet`（交易者 proxy 钱包）
- `asset`（ERC1155 token id）
- `side`（BUY/SELL）
- `size`、`price`、`timestamp`、`transactionHash`

**它不是“maker/taker 模型”。**

### 3.2 “maker/taker + side 反转”更像另一种流

“side 相对于 taker，需要对 maker 反转”通常对应：
- CLOB 私有用户流（`clob_user/trade`）中的 `maker_address` 等字段语义

但 `clob_user/*` 需要 clob_auth，且现实中你无法订阅“别人”的私有流。

> 落地建议：以 `activity/trades` 的 `proxyWallet` 作为“信号归属地址”，把它定义成系统内的 `signal.wallet`，并建立一个明确的“谁被跟”的地址标准（是 proxyWallet 还是 EOA）。

---

## 4. 与当前实现对照：主要差距与风险点

### 4.1 Monitor：字段解析风险（高优先级）

当前 `src/monitor.js` 使用 `trade.maker` / `trade.taker` 来判断聪明钱，并据此构造 `signal.side` 的反转逻辑。这很可能与 `activity/trades` 的真实字段不匹配，导致：
- 监听不到聪明钱（漏信号）
- 把不相关地址当聪明钱（错信号）
- side 方向错误（反向跟单，灾难级）

### 4.2 Executor：市价单 amount 语义风险（高优先级）

`@polymarket/clob-client` 的 `UserMarketOrder.amount` 语义是：
- BUY：美元金额（USDC）
- SELL：shares 数量

当前 executor 用 `size * price * ratio` 统一算 “amount”，并把它同时用于 BUY/SELL。
这会让 SELL 单位错误（把 USDC 当 shares 或反过来），结果可能是：
- 下单失败
- 下单规模显著偏离
- 产生意外仓位（最坏）

### 4.3 幂等性：应以 transactionHash/order_id 为核心键

目前 executor 的去重 key 是 `${tokenId}-${side}-${timestamp}`，并且 5 秒后释放。WS 重连、重复推送、或同秒多笔交易都可能造成重复下单/漏下单。

建议定义：
- `signalId = <source>:<transactionHash>:<asset>:<side>:<size>:<price>`（最小可行）
- 数据库层做 UNIQUE 约束或“先写入占位再执行”的 outbox 模式

### 4.4 Telegram 私钥交互：风险巨大

`/wallet` 会把私钥明文发到 Telegram 聊天中。这在安全上不可接受（聊天记录、截图、转发、设备被盗等）。

短期建议：
- 不在 Telegram 返回私钥；改为“只显示地址 + 引导用户自行导入/绑定”
- 或把“密钥输入/导出”搬到 Telegram Mini App / Web 页面（HTTPS）中，并在前端本地加密再提交

### 4.5 MASTER_KEY 默认值：生产环境会被“误配置毁灭”

`MASTER_KEY` 若未配置会回退到默认字符串，这意味着一旦误部署或忘配环境变量，攻击者拿到 DB 就可离线解密全部私钥。

建议：`MASTER_KEY` 缺失即启动失败（fail-fast）。

---

## 5. 建议的落地路线图（按“先正确、再稳、再强”）

### 5.1 MVP（1~3 天）：把“数据契约 + 正确性”打穿

目标：能稳定跟随少量钱包，小额执行，且可解释、可追溯、可回放。

建议任务：
1. **修正 `activity/trades` 的字段解析**：以 `proxyWallet` 为 wallet，`asset` 为 tokenId。
2. **修正 BUY/SELL 的 amount 语义**：BUY 以 USDC 金额；SELL 以 shares（来自 signal.size）。
3. **幂等与去重**：以 `transactionHash`（或等价的不可变字段）生成 signalId，DB 做幂等防重。
4. **最小风控**：单笔上限、最小金额阈值、基础熔断开关（全局 pause）。

### 5.2 Alpha（1~2 周）：把“滑点/执行鲁棒性/状态一致性”做好

目标：不追求极致速度，先追求“不会因为常见异常把系统搞炸”。

建议任务：
- **滑点保护**：当价格偏离目标成交价超过阈值时，放弃或改限价单。
- **三段式重试**：先限价贴近目标价 → 超时微调 → 再降量/取消（避免一直 FOK 失败）。
- **断线补偿**：WS 断线后用 REST 拉取断线窗口内的 trades，补齐信号（文档的 polling fallback 思路可借鉴）。

### 5.3 Pro（持续演进）：护城河与体验

目标：把“信号质量 + 用户体验 + 安全边界”做成产品竞争力。

建议任务：
- **聪明钱发现引擎**：每日/每小时更新、评分、淘汰（数据与口径固定化）。
- **NegRisk/等价暴露映射**：把“买 A Yes”和“买其它 No”的等价暴露识别成同一意图（这属于高级能力，务必后置）。
- **非托管/更强安全**：KMS/硬件密钥/本地代理模式（服务端不持私钥）作为高端选项。

---

## 6. 最小可行的“验证方法”（建议写进工程规范）

1. **录制一段 WS `activity/trades` 原始消息**（脱敏后保存到 fixtures）
2. 对 monitor 做“回放测试”：输入消息 → 输出 signal（字段必须稳定）
3. 对 executor 做“dry-run 模式”：只生成订单参数，不真正 post
4. 在小额真实环境验证：BUY 与 SELL 两个方向各 3 次，确认 amount 口径正确

---

## 7. 下一步我建议你让我直接做的三件事（最小改动、最高收益）

1. 修正 `services/copy-trading-service/src/monitor.js`：按 `activity/trades` schema 解析 `proxyWallet/asset/side/size/price/transactionHash`，并把 signalId 做成幂等键。  
2. 修正 `services/copy-trading-service/src/executor.js`：按 clob-client 语义区分 BUY/SELL 的 `amount`。  
3. 修正 `services/copy-trading-service/src/wallet/crypto.js` 与 `src/bot/index.js`：`MASTER_KEY` 缺失 fail-fast；Telegram 不再明文回显私钥（至少提供“安全模式”开关）。

